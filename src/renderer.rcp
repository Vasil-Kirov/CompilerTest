renderer
#import gl
#import math as m
#import io
#import os

vert_shader := #embed_bin "../src/shaders/main.vert";
frag_shader := #embed_bin "../src/shaders/main.frag";

struct ctx {
    vao: u32,
    vbo: u32,
    program: u32,
}

compile_shader :: fn (shader: u32, src: **u8, name: string) {
    gl.ShaderSource(shader, 1, src, null);
    gl.CompileShader(shader);

    success := @i32 0;
    gl.GetShaderiv(shader, gl.COMPILE_STATUS, &success);
    if success == 0 {
        info_log := [512]u8 {};
        gl.GetShaderInfoLog(shader, 512, null, &info_log[0]);
        io.println("Error compiling % shader\n%s", name, &info_log[0]);
        os.abort();
    }
}

gl_callback :: fn(src: u32, t: u32, id: u32, severity: u32, len: u32, msg: *u8, user: ?*) {
    io.println("GL Message: %s", msg);
}

create_ctx :: fn() -> ctx {
    result := ctx {};
    gl.GenVertexArrays(1, &result.vao);
    gl.GenBuffers(1, &result.vbo);
    vert_shader_gl := gl.CreateShader(gl.VERTEX_SHADER);
    frag_shader_gl := gl.CreateShader(gl.FRAGMENT_SHADER);
    compile_shader(vert_shader_gl, &vert_shader, "vertex");
    compile_shader(frag_shader_gl, &frag_shader, "fragment");

    result.program = gl.CreateProgram();
    gl.AttachShader(result.program, vert_shader_gl);
    gl.AttachShader(result.program, frag_shader_gl);
    gl.LinkProgram(result.program);
    gl.Disable(gl.DEPTH_TEST);

    gl.Enable(gl.DEBUG_OUTPUT);
    gl.Enable(gl.DEBUG_OUTPUT_SYNCHRONOUS);
    gl.Enable(gl.MULTISAMPLE);
    gl.Enable(gl.LINE_SMOOTH);
    gl.DebugMessageCallback(gl_callback, null);
    gl.DebugMessageControl(gl.DONT_CARE, gl.DONT_CARE, gl.DEBUG_SEVERITY_MEDIUM, 0, null, true);

    success := @i32 0;
    gl.GetProgramiv(result.program, gl.LINK_STATUS, &success);
    if success == 0 {
        info_log := [512]u8 {};
        gl.GetProgramInfoLog(result.program, 512, null, &info_log[0]);
        io.println("Error linking shader\n%s", &info_log[0]);
        os.abort();
    }
    gl.DeleteShader(vert_shader_gl);
    gl.DeleteShader(frag_shader_gl);

    return result;
}

set_uniform :: fn(c: *ctx, name: string, passed: $T) {
    passed := passed;
    t := type_of passed;
    loc := gl.GetUniformLocation(c.program, name.data);
    if loc == -1 {
        io.println("Failed to find uniform % in shader", name);
        return;
    }

    if t == f32 {
        v := *@*f32 &passed;
        gl.Uniform1f(loc, v);
    } else if t == f64 {
        v := *@*f64 &passed;
        gl.Uniform1f(loc, @f32 v);
    } else if t == m.v2 {
        v := @*m.v2 &passed;
        gl.Uniform2f(loc, v.x, v.y);
    } else if t == m.v3 {
        v := @*m.v3 &passed;
        gl.Uniform3f(loc, v.x, v.y, v.z);
    } else {
        io.println("set_uniform(), unsupported type: %", t);
    }
}

draw_verts :: fn(c: *ctx, verts: []m.v3) {
    offset := 0;
    gl.BindVertexArray(c.vao);
    gl.VertexAttribPointer(0, 3, gl.FLOAT, false, @i32 size_of m.v3, @*u8 offset);
    gl.EnableVertexAttribArray(0);
    gl.BindBuffer(gl.ARRAY_BUFFER, c.vbo);
    gl.BufferData(gl.ARRAY_BUFFER, @uint verts.count * @uint size_of m.v3, verts.data, gl.STATIC_DRAW);
    gl.UseProgram(c.program);
    gl.DrawArrays(gl.TRIANGLES, 0, @i32 verts.count);
}

draw_lines :: fn(c: *ctx, verts: []m.v3, width: f32) {
    offset := 0;
    gl.LineWidth(width);
    gl.BindVertexArray(c.vao);
    gl.VertexAttribPointer(0, 3, gl.FLOAT, false, @i32 size_of m.v3, @*u8 offset);
    gl.EnableVertexAttribArray(0);
    gl.BindBuffer(gl.ARRAY_BUFFER, c.vbo);
    gl.BufferData(gl.ARRAY_BUFFER, @uint verts.count * @uint size_of m.v3, verts.data, gl.STATIC_DRAW);

    gl.UseProgram(c.program);
    gl.DrawArrays(gl.LINE_STRIP, 0, @i32 verts.count);
}

map :: fn (t: f32, from1: f32, to1: f32, from2: f32, to2: f32) -> f32 {
 return from2 + ((to2 - from2) / (to1 - from1)) * (t - from1);
}



